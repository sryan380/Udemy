!SESSION 2022-06-26 16:51:01.086 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-26 16:51:04.535
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:51:04.535
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@bb6869a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@506b083,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:51:04.535
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5eee3da9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ace2408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-26 16:51:06.084
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2022-06-26 16:54:05.483
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:80)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:136)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:173)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:270)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5150)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4782)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-06-26 16:54:07.327 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-26 16:54:10.536
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:54:10.536
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ec92631,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76220ef1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:54:10.536
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65ad2b42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294ebe11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-26 16:54:12.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-26 16:55:28.841 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-26 16:55:32.541
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:55:32.541
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34695b23,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@611a2d82,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-26 16:55:32.541
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6774f264,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2299f6d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-26 16:55:34.186
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-26 17:10:19.815
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

public class mainApp {

	public static void main(String[] args) {
		
		System.out.println("Hello, Steve");
		
		int myFirstNumber = (5 + 5) =;
		System.out.println(myFirstNumber);
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-26 17:10:19.816
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-26 17:10:19.816
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-26 17:10:19.829
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

public class mainApp {

	public static void main(String[] args) {
		
		System.out.println("Hello, Steve");
		
		int myFirstNumber = (5 + 5) =;
		System.out.println(myFirstNumber);
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-26 17:10:19.829
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-26 17:10:19.830
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-27 23:26:55.359 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-27 23:27:04.506
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-27 23:27:04.506
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5600a278,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@549d14fe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-27 23:27:04.506
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77d54a41,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41026e5c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-27 23:27:06.622
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-28 14:11:51.543 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-28 14:12:00.323
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-28 14:12:00.323
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-28 14:12:00.323
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-28 14:12:02.554
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-29 16:41:36.691 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-29 16:41:44.849
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-29 16:41:44.849
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-29 16:41:44.849
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c8abec7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-29 16:41:47.073
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-29 17:58:39.310 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-29 17:58:42.971
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-29 17:58:42.971
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@265287ec,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7507d96c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-29 17:58:42.971
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7210f559,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49b9ba6a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-29 17:58:44.707
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-30 13:38:56.848 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-30 13:39:06.698
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-30 13:39:06.698
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@722b3ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6487f7f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-30 13:39:06.698
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b62475a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-30 13:39:08.982
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-01 11:55:50.097 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-01 11:55:59.242
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-01 11:55:59.242
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-01 11:55:59.242
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-01 11:56:01.784
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-02 15:16:35.845 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-02 15:16:43.137
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-02 15:16:43.137
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-02 15:16:43.137
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-02 15:16:45.201
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-03 16:04:06.085 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-03 16:04:14.917
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-03 16:04:14.917
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-03 16:04:14.917
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-03 16:04:17.046
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-04 12:38:45.542 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-04 12:39:04.552
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-04 12:39:04.552
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-04 12:39:04.552
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-04 12:39:07.366
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-05 12:30:55.471 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-05 12:31:04.474
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-05 12:31:04.474
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-05 12:31:04.474
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-05 12:31:06.842
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-06 13:44:58.383 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-06 13:45:09.394
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-06 13:45:09.394
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-06 13:45:09.394
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-06 13:45:11.800
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-07 11:06:38.054 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-07 11:06:53.362
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-07 11:06:53.362
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-07 11:06:53.362
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@410f53b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@265287ec,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-07 11:06:55.769
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-08 15:17:04.349 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-08 15:17:21.038
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-08 15:17:21.038
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-08 15:17:21.038
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-08 15:17:23.358
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-08 22:34:48.747 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-08 22:34:58.827
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-08 22:34:58.827
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@722b3ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6487f7f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-08 22:34:58.827
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b62475a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-08 22:35:01.110
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-10 21:04:38.464 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-10 21:05:03.040
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-10 21:05:03.040
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-10 21:05:03.040
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c8abec7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-10 21:05:05.243
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-07-11 01:10:44.572
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

public class Printer {
	
	private int tonerLevel;
	private int pagesPrinted = 0;
	private boolean duplex;
	
	public Printer(int tonerLevel, int pagesPrinted, boolean duplex) {
		if(tonerLevel > -1 && tonerLevel <= 100) {
			this.tonerLevel = tonerLevel;
		} else {
			this.tonerLevel = -1;
		}
		
		this.pagesPrinted = pagesPrinted;
		this.duplex = duplex;
	}
	
	public int addToner(int tonerAmount) {
		if(tonerAmount > 0 && tonerAmount <= 100) {
			if(this.tonerLevel + tonerAmount > 100) {
				return -1;
			} else {
				this.tonerLevel + tonerAmount
			}
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-11 01:10:44.573
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-11 01:10:44.574
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-11 01:10:44.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

public class Printer {
	
	private int tonerLevel;
	private int pagesPrinted = 0;
	private boolean duplex;
	
	public Printer(int tonerLevel, int pagesPrinted, boolean duplex) {
		if(tonerLevel > -1 && tonerLevel <= 100) {
			this.tonerLevel = tonerLevel;
		} else {
			this.tonerLevel = -1;
		}
		
		this.pagesPrinted = pagesPrinted;
		this.duplex = duplex;
	}
	
	public int addToner(int tonerAmount) {
		if(tonerAmount > 0 && tonerAmount <= 100) {
			if(this.tonerLevel + tonerAmount > 100) {
				return -1;
			} else {
				this.tonerLevel + tonerAmount
			}
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-11 01:10:44.598
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-11 01:10:44.598
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-11 01:10:45.424
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

public class Printer {
	
	private int tonerLevel;
	private int pagesPrinted = 0;
	private boolean duplex;
	
	public Printer(int tonerLevel, int pagesPrinted, boolean duplex) {
		if(tonerLevel > -1 && tonerLevel <= 100) {
			this.tonerLevel = tonerLevel;
		} else {
			this.tonerLevel = -1;
		}
		
		this.pagesPrinted = pagesPrinted;
		this.duplex = duplex;
	}
	
	public int addToner(int tonerAmount) {
		if(tonerAmount > 0 && tonerAmount <= 100) {
			if(this.tonerLevel + tonerAmount > 100) {
				return -1;
			} else {
				this.tonerLevel + tonerAmount
			}
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-11 01:10:45.424
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-11 01:10:45.424
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-07-11 15:40:29.886 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-11 15:43:54.159
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-11 15:43:54.159
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-11 15:43:54.159
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-11 15:43:56.399
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-12 15:07:18.030 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-12 15:07:27.714
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-12 15:07:27.714
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6487f7f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b62475a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-12 15:07:27.714
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@624d778e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-12 15:07:30.422
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-13 13:36:29.614 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-13 13:36:46.884
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-13 13:36:46.884
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-13 13:36:46.884
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-13 13:36:49.155
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-14 16:02:53.179 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-14 16:03:02.333
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-14 16:03:02.333
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-14 16:03:02.333
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-14 16:03:04.670
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-15 17:57:01.121 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-15 17:57:09.307
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-15 17:57:09.307
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-15 17:57:09.307
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-15 17:57:11.472
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-16 13:47:56.938 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-16 13:48:07.011
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-16 13:48:07.011
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@624d778e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-16 13:48:07.011
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-16 13:48:09.170
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-16 23:08:37.361 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-16 23:08:57.562
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-16 23:08:57.562
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-16 23:08:57.562
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c8abec7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-16 23:08:59.780
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-17 15:45:07.736 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-17 15:45:15.584
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-17 15:45:15.584
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-17 15:45:15.584
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-17 15:45:17.640
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-18 14:46:13.629 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-18 14:46:38.961
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-18 14:46:38.961
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-18 14:46:38.961
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-18 14:46:41.136
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jface 4 2 2022-07-18 20:22:13.555
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.HashSet.add(Object)" because "map" is null
	at org.eclipse.jdt.ui.actions.AddGetterSetterAction$AddGetterSetterSelectionStatusValidator.validate(AddGetterSetterAction.java:367)
	at org.eclipse.ui.dialogs.CheckedTreeSelectionDialog.updateOKStatus(CheckedTreeSelectionDialog.java:238)
	at org.eclipse.ui.dialogs.CheckedTreeSelectionDialog.lambda$1(CheckedTreeSelectionDialog.java:324)
	at org.eclipse.jface.viewers.CheckboxTreeViewer$1.run(CheckboxTreeViewer.java:168)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.CheckboxTreeViewer.fireCheckStateChanged(CheckboxTreeViewer.java:165)
	at org.eclipse.jface.viewers.CheckboxTreeViewer.handleSelect(CheckboxTreeViewer.java:295)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1205)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:263)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:421)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.dialogs.CheckedTreeSelectionDialog.open(CheckedTreeSelectionDialog.java:253)
	at org.eclipse.jdt.ui.actions.AddGetterSetterAction.run(AddGetterSetterAction.java:316)
	at org.eclipse.jdt.ui.actions.AddGetterSetterAction.run(AddGetterSetterAction.java:566)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-07-19 21:48:54.438 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-19 21:49:02.783
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-19 21:49:02.783
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-19 21:49:02.783
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-19 21:49:05.104
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-20 13:18:58.882 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-20 13:19:07.650
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-20 13:19:07.650
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-20 13:19:07.650
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-20 13:19:09.861
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-21 13:23:31.423 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-21 13:23:42.323
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-21 13:23:42.323
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45f241df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f36f34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-21 13:23:42.323
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-21 13:23:44.725
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:24.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:24.666
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:24.666
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:25.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:25.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:25.207
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:25.654
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:25.656
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:25.656
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:34.708
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:34.710
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:34.710
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:34.719
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:34.720
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:34.720
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:42.249
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j<bo)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:42.250
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:42.250
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:42.262
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j<bo)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:42.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:42.263
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:45.779
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< bora)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:45.780
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:45.780
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:47.796
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< borad.l)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:47.796
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:47.797
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:47.808
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< borad.l)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:47.809
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:47.809
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:51.325
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< b)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:51.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:51.327
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:51.338
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< b)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:51.339
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:51.340
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:54.345
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:46:54.347
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:46:54.347
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:46:54.356
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:46:54.357
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:46:54.357
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:47:02.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:47:02.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:47:02.017
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:47:09.158
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:47:09.159
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:47:09.159
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:47:15.265
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j)=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:47:15.266
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:47:15.266
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:47:18.870
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-07-21 13:47:18.872
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-07-21 13:47:18.872
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-07-21 13:47:18.881
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package mainApp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

import Playlist.Album;
import Playlist.Song;

public class mainApp {
	
	public static void main(String[] args) {
		
		int[][] board = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; //length 4
		int[][] board2 = {{1,1},{1,0}}; // length 2
		
		
		gameoflife(board);
		
	}
	
	private static final String INVALID = "Invalid Value";
	
	public static int[][] gameoflife(int[][] board) {
		
		int[][] output = new int[board.length][board[0].length];
		
		for(int l = 0; l < board.length; l++) {
			for(int m = 0; m < board[0].length; m++) {
				int aliveNeighbours = 0;
				for(int i = -1; i <= 1;i++) {
					for(int j = -1; j <= 1; j++) {
						if((l+j=0 && l+j< board.length)
					}
				}
			}
		}
		return output;
	}
	
	public static boolean inRange(int[][] board, int i, int x) {
		try {
			int num = board[i][x];
			return true;
			
		} catch(Exception e) {
			return false;
		}
	}
	
	public static int[] twoSum(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
        	System.out.println(nums.length);
            for(int v = i+1; v <= nums.length - 1; v++){
                if(nums[i] + nums[v] == target){
                	int[] result = {i,v};
                	System.out.println(i + " " + v);
                    return result;
                }
            }
        }
        return null;
    }
	
	public static void reverse(int[] array) {
		System.out.println("Array = " + Arrays.toString(array));
		int temp;
		for(int i = 0; i < array.length/2; i++) {
			temp = array[array.length - i -1];
			array[array.length - i -1] = array[i];
			array[i] = temp;
		}
		System.out.println("Reverse Array = " + Arrays.toString(array));
	}
	
	public static int readInteger() {
		Scanner sc = new Scanner(System.in);
		return sc.nextInt(); 
	}
	
	public static int[] readElements(int count) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[count];
		int index = 0;
		while(sc.hasNext()){
			array[index] = sc.nextInt();
			index++;
		}
		return array;
	}
	
	public static int findMin(int[] array) {
		int min = Integer.MAX_VALUE;
		int counter = 0;
		for(int i: array) {
			if(i < min) {
				min = i;
			}
			counter++;
		}
		return min;
	}
	
	public static int[] getInteger(int number){
        Scanner sc = new Scanner(System.in);
        int[] array = new int[number];
        for(int i = 0; i < number; i++) {
            array[i] = sc.nextInt();
        }
        return array;
    }
	
	public static int[] sortIntegers(int[] toSort) {
		int[] sortedArray = new int[toSort.length];
		for(int i = 0; i < toSort.length; i++) {
			sortedArray[i] = toSort[i];
		}
		boolean flag = true;
		int temp;
		while(flag) {
			flag = false;
			for(int i = 0; i < toSort.length -1 ; i++) {
				if(sortedArray[i] < sortedArray[i+1]) {
					temp = sortedArray[i];
					sortedArray[i] = sortedArray[i+1];
					sortedArray[i+1] = temp;
					flag = true;
				}
			}
		}
		return sortedArray;
	}
	
	public static void printArray(int[] array) {
		int counter = 0;
		for(int a: array) {
			System.out.println("Element " + counter + " contents " + a);
			counter++;
		}
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0 || extraBuckets < 0) {
			return -1;
		}
		
		double area = width * height;
		double areaToCover = area - (extraBuckets * areaPerBucket);
		
		return (int) Math.ceil(areaToCover / areaPerBucket);
		
	}
	
	public static int getBucketCount(double width, double height, double areaPerBucket) {
		if(width <= 0 || height <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		double area = width * height;
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	public static int getBucketCount(double area, double areaPerBucket) {
		if(area <= 0 || areaPerBucket <= 0) {
			return -1;
		}
		
		return (int) Math.ceil(area / areaPerBucket);
		
	}
	
	public static void inputThenPrintSumAndAverage() {
		Scanner sc = new Scanner(System.in);
		
		int sum = 0;
		long average = 0L;
		int count = 0;
		
		while(true) {
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				sum += number;
				count++;
			} else {
				break;
			}
		}
		if(sum != 0) {
			Double calulatedAverage = ((double) sum / (double) count);
			average = Math.round(calulatedAverage);
		}
		
		System.out.println("SUM = " + sum + " AVG = " + average);
	}
	
	public static void minAndMaxChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		
		while(true) {
			System.out.println("Enter number : ");
			
			boolean validNumber = sc.hasNextInt();
			
			if(validNumber) {
				int number = sc.nextInt();
				if(number < min) {
					min = number;
				}
				if(number > max) {
					max = number;
				}
			} else {
				break;
			}
		}
		System.out.println("Minimum number is: " + min + " Maximum number is: " + max);
		sc.close();
	}
	
	public static void readingUserInputChallenge() {
		Scanner sc = new Scanner(System.in);
		
		int counter = 0;
		int sum = 0;
		
		while(counter < 10) {
			
			System.out.println("Enter number #" + (counter + 1) + ": ");
			
			boolean hasNextInt = sc.hasNextInt();
			
			if(hasNextInt) {
				int number = sc.nextInt();
				sum += number;
				counter++;
			} else {
				System.out.println("Invalid number");
			}
			
			sc.nextLine();
			
		}
		System.out.println("Sum is : " + sum);
		sc.close();
	}
	
	public static void systemInTest() {
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter your birth year: ");
		
		boolean hasNextInt = sc.hasNextInt();
		
		if(hasNextInt) {
			int yearOfBirth = sc.nextInt();
			sc.nextLine();

			System.out.println("Enter your name: ");
			String name = sc.nextLine();
			int age = 2022 - yearOfBirth;
			
			if(age >= 0 && age <= 100) {
				System.out.println("Your name is " + name + ", and you are " + age + " years of age");
			} else {
				System.out.println("Invalid year of birth");
			}
		} else {
			System.out.println("unable to parse year of birth.");
		}
		sc.close();
		
	}
	
	public static void printSquareStar(int number) {
		if(number < 5) {
			System.out.println(INVALID);
		} else {
			for(int row = 1; row <= number; row++) {
				for(int column = 1; column <= number; column++) {
					if(row == 1 || row == number) {
						System.out.print("*");
					} else if(column == 1 || column == number) {
						System.out.print("*");
					} else if(row == column) {
						System.out.print("*");
					} else if(column == number - (row - 1)) { //column == rowCount - row + 1
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				}
				System.out.println();
			}
		}
	}
	
	public static int getLargestPrime(int number) {
		
		if(number <= 1) {
			return -1;
		}
		
		for (int i = 2; i < number; i++) {
            if (number % i == 0){
                number /= i;
                i--;
            }
        }
		return number;
	}
	
	public static boolean canPack(int bigCount, int smallCount, int goal) {
		if(bigCount < 0 || smallCount < 0 || goal < 0) {
			return false;
		}
		
		if(bigCount == 0 || goal < 5) {
			return goal <= smallCount;
		}
		
		if (goal != (bigCount * 5)) {
            if (goal > (bigCount * 5)) {
                return (goal - (bigCount * 5)) <= smallCount;
            }
            if (goal < (bigCount * 5)) {
                return (goal % 5) <= smallCount;
            }
        } else {
            return true;
        }
        return false;
	}
	
	public static void numberToWords(int number) {
		
		if(number < 0) {
			System.out.println(INVALID);;
		}
		
		int digitCount = getDigitCount(number);
		int reversed = reverse(number);
		int digitReversed = getDigitCount(reversed);
		if(reversed == 0) {
			System.out.println("Zero");
		}
		
		while(reversed > 0) {
			int toPrint = reversed % 10;
			reversed /= 10;
			switch(toPrint) {
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("Zero");
				break;
			}
		}
		if(digitCount != digitReversed) {
			for(int i = digitReversed; i < digitCount; i++) {
				System.out.println("Zero");
			}
		}
		
	}
	
	public static int reverse(int number) {
		int reverse = 0;
		while (number != 0) {
			int remainder = number % 10;
			reverse = reverse * 10 + remainder;
			number /= 10;
		}
		return reverse;
	}
	
	public static int getDigitCount(int number) {
		if(number < 0) {
			return -1;
		}
		
		int count = 1;
		number /= 10;
		
		while(number > 0) {
			count++;
			number /= 10;
		}
		return count;
	}
	
	public static boolean isPerfectNumber(int number) {
		if(number < 1) {
			return false;
		}
		
		int divisor = 1;
		int sum = 0;
		
		while(divisor < number) {
			if(number % divisor == 0) {
				sum += divisor;
			}
			divisor++;
		}
		if(sum == number) {
			return true;
		}
		return false;
	}
	
	public static void printFactors(int number) {
		if(number < 1) {
			System.out.println(INVALID);
		}
		int divisor = 1;
		
		while(divisor <= number) {
			if(number % divisor == 0) {
				System.out.println(divisor);
			}
			divisor++;
		}
		
	}
	
	public static int getGreatestCommonDivisor(int first, int second) {
		
		if(first < 10 || second < 10) {
			return -1;
		}

		int largestNumber;
		if(first > second) {
			largestNumber = first;
		} else {
			largestNumber = second;
		}
		
		boolean isDivisable = true;
		
		while(isDivisable) {
			if(first % largestNumber == 0 && second % largestNumber == 0) {
				isDivisable = false;
				return largestNumber;
			}
			largestNumber--;
		}
		return -1;
	}
	
	public static boolean isValid(int num) {
		if(num < 10 || num > 1000) {
			return false;
		}
		return true;
	}
	
	public static boolean hasSameLastDigit(int num1, int num2, int num3) {
		
		if(!isValid(num1) || !isValid(num2) || !isValid(num3)) {
			return false;
		}
		
		int num1LastDigit = num1 % 10;
		int num2LastDigit = num2 % 10;
		int num3LastDigit = num3 % 10;
		
		if(num1LastDigit == num2LastDigit || num1LastDigit == num3LastDigit || num2LastDigit == num3LastDigit) {
			return true;
		}
		return false;
		
	}
	
	public static boolean hasSharedDigit(int num1, int num2) {
		
		if(num1 < 10 || num1 > 99 || num2 < 10 || num2 > 99) {
			return false;
		}
		int num1LastDigit = num1 % 10;
		num1 /= 10;
		int num2LastDigit = num2 % 10;
		num2 /= 10;
		if(num1 == num2 || num1 == num2LastDigit || num2 == num1LastDigit || num2LastDigit == num1LastDigit) {
			return true;
		}
		return false;
	}
	
	public static int getEvenDigitSum(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		
		while(number > 0) {
			int toSum = number % 10;
			number /= 10;
			
			if(toSum % 2 == 0) {
				sum += toSum;
			}
			
		}
		
		return sum;
	}
	
	public static int sumFirstAndLastDigit(int number) {
		int sum = 0;
		if(number < 0) {
			return -1;
		}
		int last = number % 10;
		int first = number;
		while(number >= 10) {
			number = number / 10;
			first = number;
		}
		return sum = last + first;
	}
	
	public static boolean isPalindrome(int number) {
		int reverse = 0;
		int num = number;
		
		while(num != 0 || num > 0) {
			int lastDigit = num % 10;
			num /= 10;
			reverse = reverse * 10;
			reverse += lastDigit;
		}
		
		if(reverse == number) {
			return true;
		}
		return false;
	}
	
	public static int sumDigits(int number) {
		int sum = -1;
		if(number >= 10) {
			sum = 0;
			while(number > 0) {
				int n = number % 10;
				number /= 10;
				sum += n;
			}
		}
		
		return sum;
	}
	
	public static void whileChallenge() {
		int number = 4;
		int finishNumber = 20;
		int totalEven = 0;
		
		while(number <= finishNumber) {
			number++;
			
			if(totalEven >= 5) {
				break;
			}
			
			if(!isEvenNumber(number)) {
				continue;
			}
			
			totalEven++;
			System.out.println("Even number " + number);
		}
		System.out.println("Toal even numbers found = " + totalEven);
	}
	
	public static boolean isEvenNumber(int n) {
		if(n % 2 == 0) {
			return true;
		}
		return false;
	}
	
	public static boolean isOdd(int number) {
		if(number < 0) {
			return false;
		}
		if(number % 2 != 0) {
			return true;
		}
		return false;
	}
	
	public static int sumOdd(int start, int end) {
		int sum = 0;
		if(start <= end && start > 0 && end > 0) {
			for(int i = start; i <= end; i++) {
				if(isOdd(i)) {
					sum += i;
				}
			}
		} else {
			return sum = -1;
		}
		return sum;
	}
	
	public static void sumChallenge() {
		int count = 0;
		int sum = 0;
		for(int i = 1; i <= 1000; i++) {
			if((i % 5 == 0) && (i % 3 == 0)) {
				sum += i;
				count++;
				System.out.println("Found number = " + i);
			}
			if(count == 5) {
				break;
			}
		}
		System.out.println(sum);
	}
	
	public static void printPrime(int n) {
		int count = 0;
		for(int i = 1; i <= n; i++) {
			if(isPrime(i)) {
				System.out.println(i);
				count++;
			}
			if(count >= 10) {
				System.out.println("exiting for loop");
				break;
			}
		}
	}
	
	public static boolean isPrime(int n) {
		
		if(n == 1) {
			return false;
		}
		
		for(int i=2; i <= (long) Math.sqrt(n); i++) {
			if(n % i == 0) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isLeapYear(int year) {
		boolean isLeapYear = false;
		
		if(year < 1 || year > 9999) {
			return isLeapYear;
		}
		if(year % 4 == 0 && year % 100 != 0) {
			return isLeapYear = true;
		}
		if(year % 400 == 0) {
			return isLeapYear = true;
		}
		return isLeapYear;
	}
	
	public static int getDaysinMonth(int month, int year) {
		int days = -1;
		if(month < 1 || month > 12 || year < 1 || year > 9999) {
			return days;
		}
		boolean leapYear = isLeapYear(year);
		
		switch(month) {
			case 1:
				return 31;
			case 2:
				if(leapYear) {
					return 29;
				} else {
					return 28;
				}
			case 3:
				return 31;
			case 4:
				return 30;
			case 5:
				return 31;
			case 6:
				return 30;
			case 7:
				return 31;
			case 8:
				return 31;
			case 9:
				return 30;
			case 10:
				return 31;
			case 11:
				return 30;
			case 12:
				return 31;
		}
		return days;
	}
	
	public static void printNumberInWord(int number) {
		
		switch(number) {
			case 0:
				System.out.println("Zero");
				break;
			case 1:
				System.out.println("One");
				break;
			case 2:
				System.out.println("Two");
				break;
			case 3:
				System.out.println("Three");
				break;
			case 4:
				System.out.println("Four");
				break;
			case 5:
				System.out.println("Five");
				break;
			case 6:
				System.out.println("Six");
				break;
			case 7:
				System.out.println("Seven");
				break;
			case 8:
				System.out.println("Eight");
				break;
			case 9:
				System.out.println("Nine");
				break;
			default:
				System.out.println("OTHER");
				break;
		}
	}
	
	public static void printDayOfTheWeek(int day) {
		
		switch(day) {
			case 0:
				System.out.println("Sunday");
				break;
			case 1:
				System.out.println("Monday");
				break;
			case 2:
				System.out.println("Tuesday");
				break;
			case 3:
				System.out.println("Wednesday");
				break;
			case 4:
				System.out.println("Thursday");
				break;
			case 5:
				System.out.println("Friday");
				break;
			case 6:
				System.out.println("Saturday");
				break;
			default:
				System.out.println("Invalid day");
				break;
		}
	}
	
	public static void switchChallenge() {
		char switchValue = 'e';
		
		switch(switchValue) {
			case 'A': case 'B': case 'C': case 'D': case 'E':
				System.out.println("Found " + switchValue);
				break;
			default:
				System.out.println("Not Found");
		}
	}
	
	public static void switchLearining() {
		int switchValue = 6;
		
		switch(switchValue) {
			case 1:
				System.out.println("Value was 1");
				break;
			case 2:
				System.out.println("Value was 2");
				break;
			case 3: case 4: case 5:
				System.out.println("was a 3, or a 4, or a 5");
				System.out.println("Actually it was a " + switchValue);
				break;
			default:
				System.out.println("Was not 1,2,3 4 or 5");
				break;
		}
	}
	
	public static boolean isCatPlaying(boolean summer, int temperature) {
		boolean playing = false;
		
		if(summer) {
			if(temperature >= 25 && temperature <= 45) {
				playing = true;
			}
		} else {
			if(temperature >= 25 && temperature <= 35) {
				playing = true;
			}
		}
		
		return playing;
	}
	
	public static void printEqual(int x, int y, int z) {
		
		if(x < 0 || y < 0 || z < 0) {
			System.out.println(INVALID);
		} else if(x == y && x == z) {
			System.out.println("All numbers are equal");
		} else if(x != y && x != z && y != z) {
			System.out.println("All numbers are different");
		} else {
			System.out.println("Neither all are equal or different");
		}
	}
	
	public static void printYearsAndDays(long minutes) {
		
		if(minutes < 0 ) {
			System.out.println(INVALID);
		} else {
			long remaningMinutes;
			long years = minutes / 525600L;
			remaningMinutes = minutes % 525600L;
			long days = remaningMinutes / 1440L;
			
			System.out.println(minutes + " min = " + years + " y and " + days + " d");
		}
	}
	
	public static double area(double radius) {
		double area = -1.0d;
		
		if(radius < 0) {
			return area;
		}
		
		return radius * radius * Math.PI;
	}
	
	public static double area(double x, double y) {
		double area = -1.0d;
		
		if(x < 0 || y < 0) {
			return area;
		}
		return x * y;
	}
	
	public static String getDurationString(long minutes, long seconds) {
		long hours = 0;
		if(minutes >= 0 && seconds >= 0 && seconds <= 59) {
			hours = minutes / 60;
			minutes = minutes % 60;
			return hours + "h " + minutes + "m " + seconds + "s";
		} else {
			return INVALID;
		}
	}
	
	public static String getDurationString(long seconds) {
		long minutes = 0;
		if(seconds >= 0) {
			minutes = seconds / 60;
			seconds = seconds % 60;
			return getDurationString(minutes, seconds);
		} else {
			return INVALID;
		}
	}
	
	public static boolean hasTeen(int x, int y, int z) {
		return (x >= 13 && x <= 19 || y >= 13 && y <= 19 || z >= 13 && z <= 19);
	}
	
	public static boolean isTeen(int x) {
		return (x >= 13 && x <= 19);
	}
	
	public static boolean hasEqualSum(int x, int y, int z) {
		return (x + y) == z;
	}
	
	public static boolean areEqualByThreeDecimalPlaces(double x, double y) {
		boolean isEqualByThree = false;
		
		x = Math.floor(Math.abs(x * 1000d));

        y = Math.floor(Math.abs(y * 1000d));
        
		if(x == y) {
			isEqualByThree = true;
		}
		return isEqualByThree;
	}
	
	public static boolean isLeapYearIfElse(int year) {
	 if (year < 1 || year > 9999) {
            return false;
        }
        if (year % 4 == 0 && (year % 100 == 0 && year % 400 != 0)) {
            return false;
        } else if (year % 4 == 0 && (year % 100 == 0 && year % 400 == 0)) {
            return true;
        } else if (year % 4 == 0) {
            return true;
        } else {
        	return false;
        }
	}
	
	public static boolean shouldWakeUp(boolean barking, int hourOfDay) {
		boolean wakeUp = false;
		
		if(hourOfDay >= 0 && hourOfDay <= 23 && barking) {
			if(hourOfDay < 8 || hourOfDay >  22) {
				wakeUp = true;
			}
		}
		
		return wakeUp;
	}
	
	public static void printMegaBytesAndKiloBytes(int kiloBytes) {
		int megaBytes = kiloBytes / 1024;
		int remaning = kiloBytes % 1024;
		
		if(kiloBytes < 0) {
			System.out.println("Invalid Value");
		} else {
			System.out.println(kiloBytes + " KB = " + megaBytes + " MB and " + remaning + " KB");
		}
		
		
	}
	
	public static long toMilesPerHour(double kilometersPerHour){
        
        long milesPerhour = -1;
        
        if(kilometersPerHour < 0){
            return milesPerhour; 
        }
        
        return milesPerhour = Math.round(kilometersPerHour / 1.609);
        
    }
    
    public static void printConversion(double kilometersPerHour){
        long miles = toMilesPerHour(kilometersPerHour);
        if(miles < 0) {
        	System.out.println("Invalid Value");
        } else {
        	System.out.println(kilometersPerHour + " km/h = " + miles + " mi/h");
        }
        
    }
	
	public static void displayHighScorePostion(String name, int postion) {
		System.out.println(name + " managed to get to the postion " 
							+ postion + " on the high score table.");
	}
	
	public static int calculateHighScorePostion(int score) {
		if(score >= 1000) {
			return 1;
		} else if(score >= 500) {
			return 2;
		} else if(score >= 100) {
			return 3;
		} else {
			return 4;
		}
	}
	
	public static void operatorChallenge() {
		double myDouble = 20.00d;
		double myDouble2 = 80.00d;
		
		double theTotal = (myDouble + myDouble2) * 100.00d;
		double theRemainder = theTotal % 40.00d;
		
		boolean isZero = (theRemainder == 0) ? true : false;
		
		System.out.println(isZero);
		if(!isZero) {
			System.out.println("Got some remainder");
		}
	}
	
	public static void ternary() {
		boolean isCar = true;
		boolean wasCar = isCar ? true : false;
		if(wasCar) {
			System.out.println("wasCar is true");
		}
	}
	
	public static void strings() {
		String myString = "this is a string";
		
		myString = myString + ", and this is more.";
		myString = myString + " \u00A9 2019";
		System.out.println(myString);
		String numberString = "250.55";
		numberString = numberString + "49.95";
		System.out.println(numberString);
		String lastString = "10";
		int myInt = 50;
		lastString = lastString + myInt;
		System.out.println("LastString is equal to " + lastString);
		double doubleNumber = 120.47d;
		lastString = lastString + doubleNumber;
		System.out.println("LastString is equal to " + lastString);
	}
	
	public static void charAndBool() {
		char myChar = 'D';
		char unicode = '\u0044';
		char unicode2 = '\u00A9';
		System.out.println(unicode2);
		
		boolean myTrue = true;
		boolean myFalse = false;
		
		boolean isCustomerOverTwentyOne = true;
		
	}
	
	public static void floatingPointDoubleChallenge() {
		double pounds = 200d;
		double kilograms = pounds * 0.45359237d;
		System.out.println(kilograms);
	}
	
	public static void floatingPointDouble() {
		float floatMin = Float.MIN_VALUE;
		float floatMax = Float.MAX_VALUE;
		System.out.println("float max = " + floatMax);
		System.out.println("float min = " + floatMin);
		double minDouble = Double.MIN_VALUE;
		double maxDouble = Double.MAX_VALUE;
		
		int myintValue = 5 / 3;
		float myFloatValue = 5f / 3f;
		double myDoubleValue = 5.00 / 3.00;
		System.out.println("myintValue = " + myintValue);
		System.out.println("myFloatValue = " + myFloatValue);
		System.out.println("myDoubleValue = " + myDoubleValue);
		
		double pi = 3.1415927d;
		double another = 3_000_000.4_567_890d;
		System.out.println(pi);
		System.out.println(another);
	}
	
	public static void primativesChallenge() {
		byte myByte = 48;
		short myShort = 1000;
		int myInt = 20000;
		long myLong = 50000L + (10L * (myByte + myShort + myInt));
		System.out.println(myLong);
	}
	
	public static void primatives() {
		byte myMinByteValue = Byte.MIN_VALUE;
		byte myMaxByteValue = Byte.MAX_VALUE;
		System.out.println("Byte minumum value = " + myMinByteValue);
		System.out.println("Byte maximum value = " + myMaxByteValue);
		long myLongValue = 100L;
		long myMinLongValue = Long.MIN_VALUE;
		long myMaxLongValue = Long.MAX_VALUE;
		System.out.println("Long minumum value = " + myMinLongValue);
		System.out.println("Long maximum value = " + myMaxLongValue);
		short bigLongLiteralValue = (short) 2147483647234L;
		System.out.println(bigLongLiteralValue);
		byte myNewBytevalue = (byte) (myMinByteValue /2 );
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-07-21 13:47:18.881
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-07-21 13:47:18.882
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-07-22 15:08:42.137 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-22 15:08:51.714
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-22 15:08:51.714
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-22 15:08:51.714
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-22 15:08:53.971
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-23 13:37:06.960 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-23 13:37:17.733
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-23 13:37:17.733
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-23 13:37:17.733
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-23 13:37:19.937
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-24 18:27:33.788 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-24 18:27:50.781
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-24 18:27:50.781
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-24 18:27:50.781
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-24 18:27:53.023
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-07-25 13:28:34.004 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-25 13:28:54.853
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-25 13:28:54.853
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-25 13:28:54.853
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-25 13:28:57.184
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Steve'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2022-07-25 17:06:59.047
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:341)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:290)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:268)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.getImage(FixCorrectionProposal.java:102)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalLink(AbstractAnnotationHover.java:492)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalsList(AbstractAnnotationHover.java:396)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalsControl(AbstractAnnotationHover.java:377)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:306)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.internal.text.InformationControlReplacer.showInformationControl(InformationControlReplacer.java:157)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1134)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractInformationControlManager.setInformation(AbstractInformationControlManager.java:431)
	at org.eclipse.jface.internal.text.InformationControlReplacer.computeInformation(InformationControlReplacer.java:116)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformation(AbstractInformationControlManager.java:1091)
	at org.eclipse.jface.internal.text.InformationControlReplacer.replaceInformationControl(InformationControlReplacer.java:103)
	at org.eclipse.jface.text.AbstractInformationControlManager.replaceInformationControl(AbstractInformationControlManager.java:1268)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.replaceInformationControl(AbstractHoverInformationControlManager.java:794)
	at org.eclipse.jface.text.TextViewerHoverManager.replaceInformationControl(TextViewerHoverManager.java:297)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$1.lambda$0(AbstractHoverInformationControlManager.java:856)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-07-25 17:06:59.048
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:341)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:290)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:268)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.getImage(FixCorrectionProposal.java:102)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalLink(AbstractAnnotationHover.java:492)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalsList(AbstractAnnotationHover.java:396)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.createCompletionProposalsControl(AbstractAnnotationHover.java:377)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:306)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
